# チャットログ - 2025年09月23日 14:51

## ユーザーリクエスト
特殊リンクが貼られないケースを決定するルールを複数設定できるようにしたい。初期では「自mdファイル名に該当する」または「該当するワードの前後どちらかに漢字がある」場合を特殊リンク設定の例外としたい

## 実装内容

### 1. 特殊リンク例外ルールの型定義
**ファイル**: `lib/markdown-client.ts`

- **LinkExceptionRule**: 例外ルールの型定義
- **LinkSettings**: 特殊リンク設定の型定義
- **DEFAULT_LINK_EXCEPTION_RULES**: デフォルトの例外ルール

```typescript
export interface LinkExceptionRule {
  id: string
  name: string
  description: string
  enabled: boolean
  type: 'self-reference' | 'kanji-context' | 'custom'
  config?: {
    pattern?: string
    flags?: string
  }
}

export interface LinkSettings {
  rules: LinkExceptionRule[]
}

export const DEFAULT_LINK_EXCEPTION_RULES: LinkExceptionRule[] = [
  {
    id: 'self-reference',
    name: '自ファイル名参照',
    description: '自mdファイル名に該当する場合は特殊リンクを設定しない',
    enabled: true,
    type: 'self-reference'
  },
  {
    id: 'kanji-context',
    name: '漢字コンテキスト',
    description: '該当するワードの前後どちらかに漢字がある場合は特殊リンクを設定しない',
    enabled: true,
    type: 'kanji-context'
  }
]
```

### 2. 例外ルールの判定関数
**ファイル**: `lib/markdown-client.ts`

- **shouldSkipLink**: 例外ルールの判定メイン関数
- **hasKanjiContext**: 漢字コンテキストの判定
- **isKanji**: 漢字判定関数

```typescript
export function shouldSkipLink(
  match: string,
  fullText: string,
  matchIndex: number,
  currentFileName: string,
  rules: LinkExceptionRule[]
): boolean {
  const enabledRules = rules.filter(rule => rule.enabled)
  
  for (const rule of enabledRules) {
    switch (rule.type) {
      case 'self-reference':
        if (match === currentFileName) {
          return true
        }
        break
        
      case 'kanji-context':
        if (hasKanjiContext(fullText, matchIndex, match.length)) {
          return true
        }
        break
        
      case 'custom':
        if (rule.config?.pattern) {
          try {
            const regex = new RegExp(rule.config.pattern, rule.config.flags || 'g')
            if (regex.test(match)) {
              return true
            }
          } catch (error) {
            console.warn(`Invalid custom rule pattern: ${rule.config.pattern}`, error)
          }
        }
        break
    }
  }
  
  return false
}

function hasKanjiContext(text: string, matchIndex: number, matchLength: number): boolean {
  const beforeChar = text[matchIndex - 1]
  const afterChar = text[matchIndex + matchLength]
  
  const hasKanjiBefore = beforeChar && isKanji(beforeChar)
  const hasKanjiAfter = afterChar && isKanji(afterChar)
  
  return hasKanjiBefore || hasKanjiAfter
}

function isKanji(char: string): boolean {
  const code = char.charCodeAt(0)
  return (
    (code >= 0x4E00 && code <= 0x9FFF) || // CJK Unified Ideographs
    (code >= 0x3400 && code <= 0x4DBF) || // CJK Extension A
    (code >= 0x20000 && code <= 0x2A6DF) || // CJK Extension B
    (code >= 0x2A700 && code <= 0x2B73F) || // CJK Extension C
    (code >= 0x2B740 && code <= 0x2B81F) || // CJK Extension D
    (code >= 0x2B820 && code <= 0x2CEAF) || // CJK Extension E
    (code >= 0x2CEB0 && code <= 0x2EBEF) || // CJK Extension F
    (code >= 0x30000 && code <= 0x3134F)    // CJK Extension G
  )
}
```

### 3. processContentWithLinks関数の拡張
**ファイル**: `lib/markdown-client.ts`

- 現在のファイル名と例外ルールを受け取るように拡張
- 各マッチに対して例外ルールをチェック

```typescript
export function processContentWithLinks(
  html: string, 
  terms: TermFile[], 
  docs: DocFile[], 
  currentFileName: string = '',
  exceptionRules: LinkExceptionRule[] = DEFAULT_LINK_EXCEPTION_RULES
): string {
  let processedHtml = html
  
  // 用語ファイル名と一致するテキストを特殊リンクAに変換
  terms.forEach(term => {
    const termName = term.title
    const regex = new RegExp(`(?<!##)${termName}(?!##)`, 'g')
    processedHtml = processedHtml.replace(regex, (match, offset) => {
      // 例外ルールをチェック
      if (shouldSkipLink(match, processedHtml, offset, currentFileName, exceptionRules)) {
        return match // リンク化しない
      }
      return `<span class="term-link" data-term="${term.slug}">${match}</span>`
    })
  })
  
  // ドキュメントファイル名と一致するテキストを特殊リンクBに変換
  docs.forEach(doc => {
    const docName = doc.title
    const regex = new RegExp(`(?<!##)${docName}(?!##)`, 'g')
    processedHtml = processedHtml.replace(regex, (match, offset) => {
      // 例外ルールをチェック
      if (shouldSkipLink(match, processedHtml, offset, currentFileName, exceptionRules)) {
        return match // リンク化しない
      }
      return `<span class="doc-link" data-doc="${doc.path}">${match}</span>`
    })
  })
  
  return processedHtml
}
```

### 4. 設定管理システム
**ファイル**: `config/link-settings.json`

```json
{
  "rules": [
    {
      "id": "self-reference",
      "name": "自ファイル名参照",
      "description": "自mdファイル名に該当する場合は特殊リンクを設定しない",
      "enabled": true,
      "type": "self-reference"
    },
    {
      "id": "kanji-context",
      "name": "漢字コンテキスト",
      "description": "該当するワードの前後どちらかに漢字がある場合は特殊リンクを設定しない",
      "enabled": true,
      "type": "kanji-context"
    }
  ]
}
```

**ファイル**: `lib/link-settings.ts`

- **loadLinkSettings**: 設定を読み込む
- **saveLinkSettings**: 設定を保存する
- **updateLinkRule**: ルールを更新する
- **deleteLinkRule**: ルールを削除する

### 5. APIルート
**ファイル**: `app/api/link-settings/route.ts`

- **GET**: 設定を取得
- **POST**: 設定を更新

### 6. コンポーネントの更新
**ファイル**: `components/ContentPane.tsx`, `components/SubPane.tsx`

- `processContentWithLinks`の呼び出し時に現在のファイル名を渡すように修正
- ドキュメントページ: `doc.title`を渡す
- 用語ページ: `term.title`を渡す

## 技術的詳細

### 例外ルールの種類
1. **self-reference**: 自ファイル名参照
   - 現在のファイル名と一致する場合は特殊リンクを設定しない
   
2. **kanji-context**: 漢字コンテキスト
   - マッチしたテキストの前後に漢字がある場合は特殊リンクを設定しない
   
3. **custom**: カスタムルール
   - 正規表現パターンでカスタムな例外条件を設定可能

### 漢字判定の範囲
- CJK Unified Ideographs (0x4E00-0x9FFF)
- CJK Extension A-G (0x3400-0x3134F)
- 日本語、中国語、韓国語の漢字を包括的にカバー

### 設定の管理
- JSONファイルでの永続化
- API経由での動的更新
- デフォルトルールとの自動マージ

## 修正ファイル

### 新規作成
1. `config/link-settings.json`: 設定ファイル
2. `lib/link-settings.ts`: 設定管理ユーティリティ
3. `app/api/link-settings/route.ts`: 設定管理API

### 更新
1. `lib/markdown-client.ts`: 例外ルール機能の追加
2. `components/ContentPane.tsx`: 現在のファイル名を渡すように修正
3. `components/SubPane.tsx`: 現在のファイル名を渡すように修正

## 結果
✅ 自mdファイル名に該当する場合は特殊リンクが設定されません
✅ 該当するワードの前後どちらかに漢字がある場合は特殊リンクが設定されません
✅ 複数の例外ルールを設定可能です
✅ カスタムルール（正規表現）も設定可能です
✅ 設定はJSONファイルで永続化されます
✅ API経由で設定を動的に更新可能です
✅ デフォルトルールが自動的に適用されます

## 使用例
- **自ファイル名参照**: 「錬.md」ファイル内で「錬」という文字は特殊リンクにならない
- **漢字コンテキスト**: 「錬金術」という文字列で「錬」の前後に漢字があるため特殊リンクにならない
- **カスタムルール**: 正規表現で特定のパターンを除外可能

これで、特殊リンクの例外ルールを柔軟に設定できるようになりました！
