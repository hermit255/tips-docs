# 特殊リンク処理の修正 - 長い名前優先の実装

## 問題の特定

ユーザーから「実動作が正しくない。短いtermが優先されています」という報告を受け、特殊リンク処理の問題を特定しました。

### 原因
- 従来の実装では、正規表現の`replace`メソッドを使用
- 長い名前を先に処理しても、短い名前が長い名前の一部を置換してしまう問題
- 処理順序だけでは解決できない競合状態が発生

## 修正内容

### 1. 新しいアプローチの採用

従来の順次処理から、以下のアプローチに変更：

1. **全マッチ検索**: すべての用語/ドキュメントのマッチを一度に検索
2. **重複除去**: 長い名前を優先して重複するマッチを除去
3. **後ろから処理**: インデックスのずれを防ぐため後ろから置換

### 2. 実装詳細

#### processTermsWithPriority関数
```typescript
function processTermsWithPriority(
  html: string, 
  sortedTerms: TermFile[], 
  currentFileName: string, 
  exceptionRules: LinkExceptionRule[]
): string {
  // すべての用語のマッチを検索
  const allMatches: Array<{term: TermFile, match: string, start: number, end: number}> = []
  
  // 重複するマッチを除去（長い名前を優先）
  const filteredMatches = allMatches.filter((match, index) => {
    return !allMatches.some((otherMatch, otherIndex) => {
      if (otherIndex === index) return false
      // 他のマッチがこのマッチの範囲内にある場合は除外
      return otherMatch.start <= match.start && otherMatch.end >= match.end
    })
  })
  
  // 後ろから処理してインデックスのずれを防ぐ
  filteredMatches.sort((a, b) => b.start - a.start)
}
```

#### processDocsWithPriority関数
同様の処理をドキュメント用にも実装

### 3. デバッグ機能の追加

動作確認のため、以下のデバッグログを追加：

- 処理対象の用語リスト
- 検索された全マッチ
- フィルタリング後のマッチ
- 実際に作成されたリンク

### 4. テスト用ファイルの作成

#### 用語ファイル
- `terms.md` - 短い名前の用語
- `terms_01.md` - 長い名前の用語

#### ドキュメントファイル
- `simpleTest.md` - シンプルなテストケース
- `linkTest.md` - 包括的なテストケース

## 技術的な改善点

### 1. 競合解決の確実性
- 全マッチを事前に検索することで、競合を確実に検出
- 長い名前を優先するロジックを明確に実装

### 2. インデックス管理
- 後ろから処理することで、置換によるインデックスのずれを防止
- 文字列の部分置換を正確に実行

### 3. デバッグ性の向上
- 詳細なログ出力で動作を追跡可能
- 問題の特定と修正が容易

## 期待される動作

### テストケース
- "terms_01" → 長い名前の用語（terms_01）にリンク
- "terms" → 短い名前の用語（terms）にリンク
- "##terms##" → リンク化されない

### 優先順位
1. 長い名前の用語/ドキュメント
2. 短い名前の用語/ドキュメント
3. ##で囲まれたテキストは除外

## 実装完了

- Docker Composeでサービスを再起動
- デバッグログを追加して動作確認可能
- テスト用ファイルを作成して検証環境を整備
